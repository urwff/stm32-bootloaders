# 问题记录

---

## CMake 添加源文件和头文件的正确用法

- **日期**：2026-02-09
- **分类**：#理解错误
- **技术**：CMake, STM32, 嵌入式开发

### 问题描述

在 CMakeLists.txt 中添加源文件和头文件时，混淆了两个命令的参数类型：

1. **`target_sources` 错误**：传入了目录路径 `Core/Src`，但该命令需要的是**具体的源文件路径**（如 `Core/Src/main.c`）

2. **`target_include_directories` 错误**：传入了头文件路径 `Core/interface/usart_bootloader.h`，但该命令需要的是**目录路径**（如 `Core/interface`）

### 解决方案

| 命令 | 用途 | 参数类型 |
|------|------|----------|
| `target_sources` | 添加源文件（.c/.cpp） | **具体文件路径**（不能是目录） |
| `target_include_directories` | 添加头文件搜索路径 | **目录路径**（不能是文件） |

正确示例：
```cmake
# 添加源文件 - 需要具体文件
target_sources(${CMAKE_PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/Core/interface/usart_bootloader.c
)

# 添加头文件目录 - 需要目录路径
target_include_directories(${CMAKE_PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/Core/Inc
    ${CMAKE_CURRENT_SOURCE_DIR}/Core/interface
)
```

---

## 自定义 Bootloader 与系统 Bootloader 的区别

- **日期**：2026-02-10
- **分类**：#知识盲点
- **技术**：STM32, Bootloader, BOOT0

### 问题描述

不清楚自己写的自定义 Bootloader 和 STM32 内置的系统 Bootloader（ROM 中的）的区别，误以为需要拉高 BOOT0 引脚才能进入自己的 Bootloader。

### 解决方案

| 类型 | 位置 | BOOT0 | 进入方式 |
|------|------|-------|---------|
| 系统 Bootloader | ROM（出厂固化） | BOOT0=1 | 拉高 BOOT0 + 复位 |
| 自定义 Bootloader | Flash 0x08000000 | BOOT0=0 | 正常上电启动即可 |

自定义 Bootloader 就是一个普通 Flash 程序，MCU 上电后从 Flash 启动，先运行 Bootloader，再由 Bootloader 决定是否跳转到 APP（0x08004000）。**不需要动 BOOT0 引脚。**

---

## STM32F103xE Flash 页地址计算

- **日期**：2026-02-10
- **分类**：#知识盲点
- **技术**：STM32, Flash, 嵌入式开发

### 问题描述

不清楚 STM32F103xE 每页 2KB 的 Flash 地址是如何排布和计算的。

### 解决方案

每页大小 2KB = `0x800` 字节，从 `0x08000000` 开始连续排列：

- **页起始地址** = `0x08000000 + 页号 × 0x800`
- **已知任意地址求页起始** = `addr & 0xFFFFF800`
- **已知长度求页数** = `(length + 0x7FF) / 0x800`（向上取整）

关键页地址：第 0 页 `0x08000000`，第 8 页 `0x08004000`（APP 起始），第 32 页 `0x08010000`（测试区域）。

---

## 串口数据位与 Flash 半字写入对齐

- **日期**：2026-02-11
- **分类**：#知识盲点
- **技术**：STM32, USART, FLASH, 嵌入式开发

### 背景信息

- **正在实现的功能**：实现 USART Bootloader 的 Flash 写入功能
- **当前操作**：明确 `HAL_UARTEx_RxEventCallback` 参数含义及 Flash 写入限制

### 问题描述

1. **串口发送单元**：确认了 STM32 串口在标准 8 位配置下是按字节（Byte）发送的。
2. **回调参数**：`HAL_UARTEx_RxEventCallback` 中的 `Size` 参数表示本次接收到的实际字节数。
3. **Flash 写入约束**：Flash 写入前必须先擦除（恢复为 0xFF），否则无法正确写入。
4. **对齐与拼接**：STM32F1 的 Flash 编程通常要求按 16 位半字（Half-word）进行。如果接收到的字节包长度为奇数，最后一个字节无法直接写入，需要与后续数据拼接组合成半字。

### 解决方案

1. **基本原则**：始终确保目标地址在写入前已处于擦除态。
2. **字节流处理**：使用静态变量或缓存区保存未能凑成半字的“孤儿字节”。
3. **逻辑拼接**：当新字节到来时，与缓存字节组合成 `uint16_t` 后调用 `HAL_FLASH_Program`。在数据流结束时，若仍有剩余字节，使用 `0xFF` 填充高位后强制写入。

---

## 流式数据处理：枚举四分支 vs 线性逻辑

- **日期**：2026-02-11
- **分类**：#知识盲点 | #优化
- **技术**：C语言, 逻辑设计, 嵌入式开发

### 背景信息

- **正在实现的功能**：USART Bootloader 的跨包 Flash 写入（需处理 16 位对齐）
- **当前操作**：对比“枚举所有可能性”与“线性流式处理”两种实现方案

### 问题描述

在处理需要跨包拼接的数据流（如串口收到的字节流拼成 16 位写入 Flash）时，容易陷入**枚举所有组合**的误区：
- **组合状况**：(上次剩/没剩) × (本次包奇/偶) = **4 种独立情况**。
- **存在的弊端**：
    1. **代码冗余**：每个分支内都要写类似的 `for` 循环。
    2. **地址计算复杂**：接力写入（Cross-packet relay）会产生 `address + i + 1` 这种偏移，极易算错导致覆盖错误。
    3. **容易丢失数据**：在枚举逻辑中，很难保证 `last_byte` 在每一个分支都被正确提取、拼接并写入。
    4. **边界风险**：如果新包长度只有 1，多层嵌套的 `if-else` 和循环条件极易触发越界或逻辑跳空。

### 解决方案

采用**线性流式处理（Linear Processing）**，不再关注包的奇偶性，而是关注“数据对”的提取：

1. **Step 1: 处理接力（Relay）**：如果上次剩了 1 字节且本次有新数据，强行拼成第 1 对并写入，移动地址和本次数据的起点。
2. **Step 2: 批量处理（Batch）**：从新起点开始，循环提取成对的字节写入。
3. **Step 3: 存留残余（Remainder）**：处理完所有成对数据后，如果最后还剩 1 个字节，存入缓存供下次使用。

**心得**：优秀的嵌入式逻辑应该像流水线一样处理数据，而不是通过复杂的条件判断去“硬套”各种排列组合。

---
